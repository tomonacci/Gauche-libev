(use control.libev)
(use gauche.collection)
(use gauche.fcntl)
(use gauche.net)
(use gauche.parameter)
(use gauche.partcont)
(use gauche.uvector)
(use picohttpparser)
(use rfc.uri)
(use srfi-1)
(use srfi-19)
(use sxml.serializer)
(use text.html-lite :only (html-escape-string))
(use text.tree :only (tree->string))
(use util.queue)
(use util.relation)
(use www.cgi)

; timeout for IO operation in seconds
(define *timeout* 60)

(define (set-nonblocking! port-or-fd)
  (sys-fcntl port-or-fd F_SETFL (logior (sys-fcntl port-or-fd F_GETFL) O_NONBLOCK)))

(define (setup-response status headers body)
  (let* ((gmt (sys-gmtime (sys-time)))
         (date (sys-strftime "%a, %d %b %Y %H:%M:%S" gmt))
         (status-message (if (= status 200) "OK" "Not found"))
         (headers
          `((Server . "httpd.gosh")
            (Date . ,date)
            (Content-Length . ,(string-size body))
            .
            ,(if (assq 'Content-Type headers)
               headers
               (acons 'Content-Type "text/html" headers))))
         )
    ($ string->u8vector $ tree->string $ list
     "HTTP/1.1 " status " " status-message "\r\n"
     (map (^p (list (car p) ": " (cdr p) "\r\n")) headers)
     "\r\n" body)
    )
  )

(define (request->response request)
  (case (string->symbol (~ request'method))
    ((GET)
     (receive (_ path query _) (uri-decompose-hierarchical (~ request'path))
       (let1 params (parameterize ((cgi-metavariables `(("REQUEST_METHOD" "GET")
                                                        ("QUERY_STRING" ,query))))
                      (cgi-parse-parameters))
         (cond ((string=? path "/")
                (values 200 () "<h1>It works!</h1>"))
               ((string=? path "/echo")
                (values 200 () (format "<pre>~a</pre>" (html-escape-string (u8vector->string (~ request'buf))))))
               (else (values 404 () "Not found :|"))))))
    (else (values 404 () "Not found :|"))))

(define (send-response client response)
  (let1 n (socket-send client response)
    (and (not (= n (u8vector-length response))) (uvector-alias <u8vector> response n))))

(define-class <client> ()
  ((socket :init-keyword :socket)
   (watcher :init-keyword :watcher :init-value #f)
   (timer :init-keyword :timer :init-value #f)
   (yields :init-value ())
   ))

(define (client-start client callback events)
  (unless (~ client'watcher)
    (set! (~ client'watcher) (make <ev-io>)))
  (unless (~ client'timer)
    (set! (~ client'timer) (make <ev-timer>))
    (set! (~ client'timer'callback)
      (lambda #f
        (for-each
         (^y (y (cons () (make-condition <error> 'message "operation timed out")))) ; TODO customize timeout condition
         (~ client'yields)))))
  (set! (~ client'timer'repeat) *timeout*)
  (ev-timer-again (~ client'timer))
  (ev-io-start (~ client'watcher) callback (socket-fd (~ client'socket)) events)
  )

(define (client-yield client callback events)
  (define *continue* #f)
  (let1 result (shift continue
                 (set! *continue* continue)
                 (~ client'yields)
                 (push! (~ client'yields) continue)
                 (client-start client (lambda #f (continue (list (callback)))) events))
    (set! (~ client'yields) (delete! *continue* (~ client'yields)))
    (if (proper-list? result)
      (car result)
      (raise (cdr result)))))

(define (client-finish client)
  (let1 watcher (~ client'watcher)
    (when (and watcher (ev-watcher-active? watcher))
      (ev-io-stop watcher)))
  (let1 timer (~ client'timer)
    (when timer
      (ev-timer-stop timer)))
  (socket-close (~ client'socket)))

(define (client-recv client buf last-len)
  (define (recv!)
    (guard (e ((and (condition-has-type? e <system-error>)
                    (= (~ e'errno) EAGAIN))
               #f))
      (socket-recv! (~ client'socket) (uvector-alias <u8vector> buf last-len))))
  (let repeat ()
    (or (recv!) (client-yield client repeat EV_READ))))

(define (client-send client buf)
  (define (send)
    (guard (e ((and (condition-has-type? e <system-error>)
                    (= (~ e'errno) EAGAIN))
               #f))
      (socket-send (~ client'socket) buf)))
  (let repeat ()
    (or (send) (client-yield client repeat EV_WRITE))))

(define (log-interaction request status body)
  (format #t "~a ~d ~d\n" (date->string (time-utc->date (current-time)) "~5.~N~z") status (string-size body)))

(define (setup-server port)
  (define (init-send client request)
    (receive (status headers body) (request->response request)
      (let* ((minor-version (~ request'minor-version))
             (Connection (assoc-ref (~ request'headers) "Connection" ""))
             (keep-alive? (or (string=? Connection "keep-alive")
                              (and (>= minor-version 1)
                                   (not (string=? Connection "close")))))
             (headers (cond ((and keep-alive? (= minor-version 0))
                             (acons 'Connection 'keep-alive headers))
                            ((and (not keep-alive?) (>= minor-version 1))
                             (acons 'Connection 'close headers))
                            (else headers))))
        (let repeat ((response (setup-response status headers body)))
          (let1 n (client-send client response)
            (if (= n (u8vector-length response))
              (begin
                (log-interaction request status body)
                (if keep-alive?
                  (init-recv client)
                  (client-finish client))
                )
              (repeat (uvector-alias <u8vector> response n))))))))

  (define (init-recv client)
    (let ((buf (make-u8vector 4096))
          (last-len 0))
      (let repeat ((last-len 0))
        (guard (e (else
                    #?=e
                    (client-finish client)))
          (let* ((n (client-recv client buf last-len))
                 (len (+ last-len n))
                 )
            (if (zero? n)
              (client-finish client)
              (if-let1 request (phr-parse-request buf len last-len)
                (init-send client request)
                (repeat len))))))))

  (define (accept-handler watcher revents)
    (guard (e (else #?=e))
      (let1 client (socket-accept server)
        (if client
          (begin
            (set-nonblocking! (socket-fd client))
            (init-recv (make <client> :socket client))
            )
          (print "accept(2) would block")))))

  (define server (make-server-socket 'inet port :backlog 128 :reuse-addr? #t))

  (set-nonblocking! (socket-fd server))
  (ev-io-start (make <ev-io>) accept-handler (socket-fd server) EV_READ)
  )

(define (setup-watchdog hz)
  (let1 interval (/. 1.0 hz)
    (ev-timer-start (make <ev-timer>) (lambda #f) interval interval)))

(define (main args)
  (ev-thread-local-loop (ev-default-loop))
  (set-signal-handler! SIGINT (^ _ (flush) (exit)))
  (setup-watchdog 5)
  (setup-server (cadr args))
  (ev-run)
  0)
